React 子组件如何向父组件传递数据

通过在子组件中定义函数去调用父组件props中父组件传递过来的方法，参数传子组件的数据

React组件生命周期:

Mounting:已插入真实DOM

依次执行constructor()

componentWillMount()

render()

componentDidMount()

Updating:正在被重新渲染

依次执行

componentWillReceiveProps()

shouldComponentUpdate()

componentWillUpdate()

render()

componentDidUpdate()

Unmounting:已移出真实DOM

生命周期的方法有:

componentWillMount:在渲染前调用，在客户端也在服务端。

componentDidMount:在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。如果你要喝其他JavaScript框架一起使用，可以在这个方法中调用setTimeout，setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。

componentWillReceiveProps:在组件接收到一个新的prop(更新后)时被调用。这个方法在初始化render时不会被调用。

shouldComponentUpdate:返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者forceUpdate时不被调用。可以在你确认不需要更新组件时使用。

componentWillUpdate:在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。

componentDidUpdate:在组件完成更新后立即调用。在初始化时不会被调用。

componentWillUnmount:在组件从DOM中移除之前立刻被调用。


this指向

ES5：

Promise:

1.了解Promise诞生的历史背景

2.学会使用Promise解决异步回调带来的问题

3.掌握Promise的进阶用法

1-2  Promise定义:

1)Promise对象用于异步计算

2)一个Promise表示一个现在，将来或永不可能可用的值。

按照用途来解释:

1)主要用于异步计算

2)可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果

3)可以在对象之间传递和操作Promise，帮助我们处理队列。

https://www.imooc.com/video/16609

1-3  JavaScript包含大量异步操作:

1)JavaScript为检查表单而生。

2)创造它的首要目标是操作DOM

3)所以，JavaScript的操作大多是异步的。

异步，则是将耗时很长的A交付的工作交给系统后，就去继续做B交付的工作。等到系统完成前面的工作之后，再通过回调或者事件，继续做A剩下的工作。

从观察者的角度看起来，AB工作的完成顺序，和交付他们的事件顺序无关，所以叫'异步'。

异步操作的常见语法

场景1:事件监听与相应

	document.getElementById("start").addEventListener("click", start, false);
	
	function start() {
	  //响应事件，进行相应操作
	}
	
	//jquery用'.on()'也是事件侦听
	
	$("#start").on("click", start);




场景2:回调,通常先调用外部函数，再传递回调函数，外部函数执行完之后，回调函数再执行

	//比较常见的有ajax
	
	$.ajax("http://baidu.com", {
	  success: function(res) {
	    //这里就是回调函数了
	  }
	});
	
场景3:或者在页面加载完毕后回调
	
	$(function() {
	  //这里也是回调函数
	});


浏览器中的JavaScript

1.异步操作以事件为主

2.回调主要出现在Ajax和File API

3.这个时候问题尚不算严重


有了Node.js之后

对异步的依赖进一步加剧了

1.无阻赛高并发，是Node.js的招牌

2.异步操作是其保障

1-4  异步回调的问题

回调地狱

	a(function(resultFromA) {
	  b(resultFromA, function(resultFromB) {
	    c(resultFromB, function(resultFromC) {
	      d(resultFromC, function(resultFromD) {
	        e(resultFromD, function(resultFromE) {
	          f(resultFromE, function(resultFromF) {
	            console.log(resultFromF);
	          });
	        });
	      });
	    });
	  });
	});

除此之外，还有更深层次的问题

遍历目录，找到其中最大的一个文件


回调有四个问题

1.嵌套层次很深，难以维护

2.无法正常使用return 和throw

3.无法正常检索堆栈信息

4.多个回调之间难以建立联系

angulaJS慕课网:

http://www.imooc.com/learn/156

compile和link:

指令执行过程

加载阶段:加载angular.js，找到ng-app指令，确定应用的边界

编译阶段：遍历DOM，找到所有的指令；根据指令代码中的template,replace,transclude转换DOM结构；如果存在compile函数则调用

链接阶段:对每一条指令运行link函数，link函数一般用来操作DOM，绑定事件监听器


1）compile函数用来对模板自身进行转换，而link函数负责在模型和视图之间进行动态关联；

2）作用域在链接阶段才会被绑定到编译之后的link函数上；compile函数仅仅在编译阶段运行一次，而对于指令的每个实例，link函数都会执行一次；

3）compile可以返回preLink和postLink函数，而link函数只会返回postLink函数；

4）如果需要修改DOM结构，应该在postLink中来做这件事情，而如果在preLink中做这件事情会导致错误；大多数时候我们只要编写link函数即可。


