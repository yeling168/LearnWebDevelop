this指向

ES5：

Promise:

1.了解Promise诞生的历史背景

2.学会使用Promise解决异步回调带来的问题

3.掌握Promise的进阶用法

1-2  Promise定义:

1)Promise对象用于异步计算

2)一个Promise表示一个现在，将来或永不可能可用的值。

按照用途来解释:

1)主要用于异步计算

2)可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果

3)可以在对象之间传递和操作Promise，帮助我们处理队列。

https://www.imooc.com/video/16609

1-3  JavaScript包含大量异步操作:

1)JavaScript为检查表单而生。

2)创造它的首要目标是操作DOM

3)所以，JavaScript的操作大多是异步的。

异步，则是将耗时很长的A交付的工作交给系统后，就去继续做B交付的工作。等到系统完成前面的工作之后，再通过回调或者事件，继续做A剩下的工作。

从观察者的角度看起来，AB工作的完成顺序，和交付他们的事件顺序无关，所以叫'异步'。

异步操作的常见语法

场景1:事件监听与相应

	document.getElementById("start").addEventListener("click", start, false);
	
	function start() {
	  //响应事件，进行相应操作
	}
	
	//jquery用'.on()'也是事件侦听
	
	$("#start").on("click", start);




场景2:回调,通常先调用外部函数，再传递回调函数，外部函数执行完之后，回调函数再执行

	//比较常见的有ajax
	
	$.ajax("http://baidu.com", {
	  success: function(res) {
	    //这里就是回调函数了
	  }
	});
	
场景3:或者在页面加载完毕后回调
	
	$(function() {
	  //这里也是回调函数
	});


浏览器中的JavaScript

1.异步操作以事件为主

2.回调主要出现在Ajax和File API

3.这个时候问题尚不算严重


有了Node.js之后

对异步的依赖进一步加剧了

1.无阻赛高并发，是Node.js的招牌

2.异步操作是其保障

1-4  异步回调的问题

回调地狱

	a(function(resultFromA) {
	  b(resultFromA, function(resultFromB) {
	    c(resultFromB, function(resultFromC) {
	      d(resultFromC, function(resultFromD) {
	        e(resultFromD, function(resultFromE) {
	          f(resultFromE, function(resultFromF) {
	            console.log(resultFromF);
	          });
	        });
	      });
	    });
	  });
	});

除此之外，还有更深层次的问题

遍历目录，找到其中最大的一个文件


回调有四个问题

1.嵌套层次很深，难以维护

2.无法正常使用return 和throw

3.无法正常检索堆栈信息

4.多个回调之间难以建立联系