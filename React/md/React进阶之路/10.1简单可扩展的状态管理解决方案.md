MobX 是Redux 之后的一个状态管理库， 基于响应式管理状态，整体是一个观察者模式的架构，存储state 的store 是被观察者，使用store 的组件是观察者。MobX 可以有多个store 对象， store使用的state 也是可变对象，这些都是和Redux 的不同点，相较于Redux, MobX 更轻量，也受到了很多开发者的青睐。

10.1 简介

Mobx通过函数响应式编程的思想使状态管理变得简单和可扩展。MobX背后的哲学是:可以从应用程序的状态中获取/衍生的数据都应该可以自动被获取/衍生。和Redux一样，Mobx一样，MobX也是采用单向数据流管理状态:通过action改变应用的state，state的改变进而会导致受其影响的views更新。

MobX包含的主要概念有4个：state(状态)、computed value(计算值)、reaction(响应)和action(动作).computed value和reaction会自动根据state的改变做最小化的更新，并且这个更新过程是同步执行的，也就是说，action更新state后，新的state是可以被立即获取的。注意，computed value采用的是延迟更新，只有当computed value被使用时它的值才会被重新计算，当computed value不再被使用时(例如使用它的组件已经被卸载)，它会被自动回收。computed value必须是纯函数，不能使用它修改state。

一般来说，驱动应用的任何数据都可以被称为state。但Mobx中提到的state实际上都是指可观测的state，因为对于不可观测的state，它们的修改并不会自动产生影响，对MobX的数据流来说是没有意义的。

MobX中大量使用了ES.next的装饰器语法，但装饰器语法目前还处于试验阶段，create-react-app创建的项目默认是不支持的。我们先来解决这个问题再继续介绍MobX。要支持装饰器语法，可以使用npm run eject命令将配置'弹出'，然后添加babel-plugin-transformdecorators-legacy 这个Babel 插件，也可以使用custom-react-scripts ( https: //www.npm s .corn/package/
custom-react-scripts ）来创建项目。本书使用custom-react-scripts 这种方式。具体方式为， 在使用
create-react-app 创建项目时，指定一scripts-version 参数的值为custom-react-scripts:

create-react-app my-app --scripts -version custom- react - scripts

10.2 主要组成

10.2.1 state

state是驱动应用的数据，是应用的核心。同Redux类似，我们依然可以把state分为三类:与领域直接相关的领域状态数据，反映应用行为(登录状态，当前是否有API请求等)的应用状态数据和代表UI状态的UI状态数据。在实际使用中，一般还会另外创建一个store来管理state，这和Redux中的store也是类似的。但MobX中，可以在一个应用中使用多个store，store中的state也是可变的。另外，MobX的state结构不需要做标准化处理，可以有多层嵌套结构，以方便UI组件使用为指导原则，这也是和Redux的state不同的地方。

MobX提供了observable和@observable两个API创建可观测的state，用法如下

observable(value)

@observable classProperty=value

这两个API几乎可以用在所有的JS数据类型上。但根据不同类型的值创建出创建出的可观测state的表现行为是有不同点的:

1.普通对象

普通对象指原型不存在或原型是Object.prototype的对象，例如，var obj＝｛'book':'react'｝、var
obj= new Object('book':'react'）都是普通对象。MobX根据普通对象创建一个可观测的新对象，新对象的属性和普通对象相同，但每一个属性都是可观测的


4.非普通对象

这里，非普通对象的概念是针对普通对象而言的，特指以自定义函数作为构造函数创建的对象。Observable会返回一个特殊的boxed values类型的可观测对象。注意，返回的boxed values对象并不会把非普通对象的属性转换成可观测的，而是保存一个指向原对象的引用，这个引用是可观测是。对原对象的访问和修改需要通过新对象的get()和set()方法操作，例如

10.2.2 computed value

computed value是根据state衍生出的新值，新值必须是通过纯函数计算得到的。computed value依赖的state改变时，会自动重新计算，前提是这个computed value有被reaction使用。也就是说，computed value采用延迟更新策略，只有被使用时才会自动更新。一般通过computed和@computed创建computed value，使用方式如下

10.2.3 reaction

1.autorun

用法:

     autorun(()=>{sideEffect})

autorun在前面的例子中已经多次用到。使用autorun时，它接收的函数会被立即触发执行一次，以后的执行就依赖于函数使用的state的变化了。autorun会返回一个清除函数disposer，当不需要观察相关state的变化时，可以调用disposer函数清除副作用

	import { observable } from "rxjs";
	
	var numbers = observable([1, 2, 3]);
	
	var sum = computed(() => numbers.reduce((a, b) => a + b, 0));
	
	var disposer = autorun(() => console.log(sum.get()));
	
	//输出
	
	numbers.push(4);
	
	//输出:10
	
	disposer(); //清除autorun
	numbers.push(5);
	
	//没有输出

