4.1.1 设置合适的state

组件state必须能代表一个组件UI呈现的完整状态集，即组件的任何UI改变都可以从state的变化中反映出来；同时，state还必须代表一个组件UI呈现的最小状态集，即state中的所有状态都用于反映组件UI的变化，没有多余的状态，也不应该存在通过其他状态计算而来的中间状态。

 我们通过一个例子来解释上面的定义。假设需要开发一个购物车组件，需要展示的信息有购物买的物品列表以及物品的总金额。设计一个错误的state。

	//错误的state 示例
	{
		purchaseList: [],
		totalCost: 0
	}

这里的state是初始状态，因此purchaseList初始化为一个空数组，totalCost初始化为0，这个state的设计确实可以满足组件UI呈现的完整状态集这一条件，但是它包含一个无用的状态totalCost，因为totalCost可以根据购买的每一项物品的价格和数量计算得出，所以有了purchaseList，就可以计算出totalCoat，totalCost属于中间状态，可以省略。


state所代表的一个组件UI呈现的完整状态集又可以分成两类数据：用作渲染组件时用到的数据的来源以及用作组件UI展现形式的判断依据。

state还容易和props以及组件的普通属性混淆。这是我们第一次提到组件的普通属性，所以先明确一下组件普通属性的定义。我们的组件都是使用ES6的class定义的，所以组件的属性其实也就是class属性(更确切的说法是class实例化对象的属性，但因为JavaScript本质上是没有类的定义的，class只不过是ES6提供的语法糖，所以这里模糊化类和对象的区别)。在ES6中，可以使用this.{属性名}定义一个class的属性，也可以说属性是直接挂载到this下的变量。因此，state，props实际上也是组件的属性，只不过它们是React为我们在Component class中预定义好的尚需经。除了state，props以外的其他组件属性称为组件的普通属性。

假设一个组件需要显示当前时间，井且这个时间每秒都会自动更新，这个组件内就需要定义一个计时器，在这个计时器中每隔1 秒更新一次组件的state。这个计时器变量并不适合定义到组件的state 中，因为它并不代表组件U 呈现状态，它只是用来更改组件的state，这时就到了组件的普通属性发挥作用的时候了。

当我们在组件中需要用到一个变量，并且它与组件的渲染无关时，就应该把这个变量定义为组件的普通属性，直接挂载到this下，而不是组件的state。还有一个更加直观的判断方法，就是看组件render方法中有没有使用这个变量，如果没有，它就是一个普通属性。

state和props又有什么区别呢？state和props都直接和组件的UI渲染有关，它们的变化都会触发组件重新渲染，但props对于使用它的组件来说是只读的，是通过父组件传递过来的，要想修改props，只能在父组件中修改，而state是组件内部自己维护的状态，是可变的。

总结一下，组件中用到的一个变量是不是应该作为state可以通过下面的4条依据进行判断

1)这个变量是否通过props从父组件中获取？如果是，那么它不是一个状态

2)这个变量是否在组件的整个生命周期中都保持不变？如果是，那么它不是一个状态

3)这个变量是否可以通过其他状态(state)或者属性(props)计算得到？如果是，那么它不是一个状态

4)这个变量是否在组件的render方法中使用?如果不是，那么它不是一个状态。这种情况下，这个变量更适合定义为组件的一个普通属性。


4.1.2 正确修改state

state可以通过this.state.{属性}的方式直接获取，但当修改state时，往往有很多陷阱需要注意。下面介绍常见的三种陷阱

1.不能直接修改state

直接修改state，组件并不会重新出发render。例如:

	//错误
	this.state.title = 'React';

正确的修改方式是使用setState();

	//正确
	this.setState({title:'React'});

2.state的更新是异步的

调用setState时，组件的state并不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且出于性能原因。可能会将多次setState的状态修改合并成一次状态修改。所以不要依赖当前的state，计算下一个state。当真正执行状态修改时，依赖的this.state并不能保证是最新的state，因为React会把多次state的修改合并成一次，这时this.state还是这几次state修改前的state。另外，需要注意的是，同样不能依赖当前props计算下一个状态，因为props的更新也是异步的。

