4.1.1 设置合适的state

组件state必须能代表一个组件UI呈现的完整状态集，即组件的任何UI改变都可以从state的变化中反映出来；同时，state还必须代表一个组件UI呈现的最小状态集，即state中的所有状态都用于反映组件UI的变化，没有多余的状态，也不应该存在通过其他状态计算而来的中间状态。

 我们通过一个例子来解释上面的定义。假设需要开发一个购物车组件，需要展示的信息有购物买的物品列表以及物品的总金额。设计一个错误的state。

	//错误的state 示例
	{
		purchaseList: [],
		totalCost: 0
	}

这里的state是初始状态，因此purchaseList初始化为一个空数组，totalCost初始化为0，这个state的设计确实可以满足组件UI呈现的完整状态集这一条件，但是它包含一个无用的状态totalCost，因为totalCost可以根据购买的每一项物品的价格和数量计算得出，所以有了purchaseList，就可以计算出totalCoat，totalCost属于中间状态，可以省略。


state所代表的一个组件UI呈现的完整状态集又可以分成两类数据：用作渲染组件时用到的数据的来源以及用作组件UI展现形式的判断依据。

state还容易和props以及组件的普通属性混淆。这是我们第一次提到组件的普通属性，所以先明确一下组件普通属性的定义。我们的组件都是使用ES6的class定义的，所以组件的属性其实也就是class属性(更确切的说法是class实例化对象的属性，但因为JavaScript本质上是没有类的定义的，class只不过是ES6提供的语法糖，所以这里模糊化类和对象的区别)。在ES6中，可以使用this.{属性名}定义一个class的属性，也可以说属性是直接挂载到this下的变量。因此，state，props实际上也是组件的属性，只不过它们是React为我们在Component class中预定义好的尚需经。除了state，props以外的其他组件属性称为组件的普通属性。

假设一个组件需要显示当前时间，井且这个时间每秒都会自动更新，这个组件内就需要定义一个计时器，在这个计时器中每隔1 秒更新一次组件的state。这个计时器变量并不适合定义到组件的state 中，因为它并不代表组件U 呈现状态，它只是用来更改组件的state，这时就到了组件的普通属性发挥作用的时候了。

当我们在组件中需要用到一个变量，并且它与组件的渲染无关时，就应该把这个变量定义为组件的普通属性，直接挂载到this下，而不是组件的state。还有一个更加直观的判断方法，就是看组件render方法中有没有使用这个变量，如果没有，它就是一个普通属性。

state和props又有什么区别呢？state和props都直接和组件的UI渲染有关，它们的变化都会触发组件重新渲染，但props对于使用它的组件来说是只读的，是通过父组件传递过来的，要想修改props，只能在父组件中修改，而state是组件内部自己维护的状态，是可变的。

总结一下，组件中用到的一个变量是不是应该作为state可以通过下面的4条依据进行判断

1)这个变量是否通过props从父组件中获取？如果是，那么它不是一个状态

2)这个变量是否在组件的整个生命周期中都保持不变？如果是，那么它不是一个状态

3)这个变量是否可以通过其他状态(state)或者属性(props)计算得到？如果是，那么它不是一个状态

4)这个变量是否在组件的render方法中使用?如果不是，那么它不是一个状态。这种情况下，这个变量更适合定义为组件的一个普通属性。


4.1.2 正确修改state

state可以通过this.state.{属性}的方式直接获取，但当修改state时，往往有很多陷阱需要注意。下面介绍常见的三种陷阱

1.不能直接修改state

直接修改state，组件并不会重新出发render。例如:

	//错误
	this.state.title = 'React';

正确的修改方式是使用setState();

	//正确
	this.setState({title:'React'});

2.state的更新是异步的

调用setState时，组件的state并不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且出于性能原因。可能会将多次setState的状态修改合并成一次状态修改。所以不要依赖当前的state，计算下一个state。当真正执行状态修改时，依赖的this.state并不能保证是最新的state，因为React会把多次state的修改合并成一次，这时this.state还是这几次state修改前的state。另外，需要注意的是，同样不能依赖当前props计算下一个状态，因为props的更新也是异步的。

举个例子，对于一个电商类应用，在购物车中，点击一次购买数量按钮，购买的数量就会加1,如果连续点击两次按钮，就会连续调用两次`this.setState({quantity: this.state.quantity + 1｝）`在React什并多次修改为一次的情况下，相当于等价执行了如下代码：

	Object.assign(
		previousState ,
		(quantity : this . state . quantity + 1),
		(quantity: this . state . quantity + 1)
	）

于是， 后面的操作覆盖前面的操作，最终购买的数量只增加1 。

如果有这样的需求，可以使用另一个接收一个函数作为参数的setState，这个函数有两个参数，第一个是当前最新状态(本次组件状态修改后生效的状态)的前一个状态preState（本次组件状态修改前的状态），第二个参数是当前最新的属性props。代码如下:

    //正确
	this.setState ((preState, props) => ({
		counter: preState.quantity + 1;
	}))

3.state的更新是一个合并的过程

当调用setState修改组件状态时，只需要传入发生改变状态的state，而不是组件完整的state，因为组件state的更新是一个合并的过程。例如，一个组件的状态为:

	this.state = {
		title :'React',
		content :'React is an wonderful JS library !'
	}

当只需要修改状态title时，将修改后的title传给setState即可:

    this.setState({title :'Reactjs'});

4.1.3 state与不可变对象

React官方建议把state当做不可变对象，一方面，直接修改this.state，组件并不会重新render；另一方面，state中包含的所有状态都应该是不可变对象。当state中的某个状态发生变化时，应该重新创建这个状态对象，而不是直接修改原来的状态。那么，当状态发生变化时，如何创建新的状态呢？根据状态的类型可以分成以下三种情况

1.状态的类型是不可变类型(数字，字符串，布尔值，null，undefined)

这种情况最简单，因为状态是不可变类型，所以直接给要修改的状态赋一个新值即可。例如，要修改count(数字类型)，title(字符串类型)、success(布尔类型)三个状态