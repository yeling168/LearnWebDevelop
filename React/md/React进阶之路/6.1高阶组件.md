6.1 基本概念

在JavaScript中，高阶函数是以函数为参数，并且返回值也是函数的函数。类似的，高阶组件(HOC)接收React组件作为参数，并且返回一个新的React组件。高阶组件本质上也是一个函数，并不是一个组件。高阶组件的函数形式如下:

    const EnhancedComponent=higherOrderCompont(WrappedComponent)

我们先通过一个简单的例子看一下高阶组件是如何进行逻辑复用的。现在有一个组件MyComponent，需要从LocalStorage中获取数据，然后渲染大截面。一般情况下，我们这么实现。

通过`{...this.props}`把传递给当前组件的属性传递给被包装的组件

高阶组件的主要功能是封装井分离组件的通用逻辑，让通用逻辑在组
件间更好地被复用。高阶组件的这种实现方式本质上是装饰者设计模式。

6.2使用场景

高阶组件的使用场景主要有以下四种：

1）操纵props

2）通过ref访问组件实例

3)组件状态提升

4)用其他元素包装组件

1.操纵props

在被包装组件接收props前，高阶组件可以先拦截到props，对props执行增加，删除或修改的操作，然后将处理后的props再传递给被包装组件。

2.通过ref访问组件实例

高阶组件通过ref获取被包装组件实例的引用，然后高阶组件就具备了直接操作被包装组件的属性或方法的能力。

3.组件状态提升

无状态组件更容易被复用。高阶组件可以通过将被包装组件的状态及相应的状态处理方法提升到高阶组件自身内部实现被包装组件的无状态化。一个典型的场景是，利用高阶组件将原本受控组件需要自己维护的状态提升到高阶组件中。

4.用其他元素包装组件

我们还可以在高阶组件渲染WrappedComponent 时添加额外的元素，这种情况通常用于为WrappedComponent 增加布局或修改样式。

6.3 参数传递

高阶组件的参数并非只能是一个组件，它还可以接收其他参数。

HOC(...params)的返回值是一个高阶组件，高阶组件需要的参数是先传递给HOC函数的。

实际上，这种形式的高阶组件大量出现在第三方库中，例如react-redux中的connect函数就是一个典驯的例子。connect的简化定义如下：

    connect(mapStateToProps,mapDispatchToProps) (WrappedComponent)

这个函数会将一个React组件连接到Redux的store上，在连接的过程中，connect通过函数参数mapStateToProps从全局store中取出当前组件需要的state，并把state转化成当前组件的props；同时通过参数mapDispatchToProps把当前组件用到的Redux的action creators以props的方式传递给当前组件。connect并不会修改传递进去的组件的定义，而是会返回一个新的组件。

注意:connect的参数mapStateToProps 、mapDispatchToProps 是函数类型，说明高阶组件的参… 数也可以是函数类型。

例如:把组件ComponentA连接到Redux上的写法类似于:

    const ConnectedComponentA=connect(mapStateToProps, mapDispatchToProps)(ComponentA);

我们可以把它拆分来看：

//connect是一个函数，返回值enhance也是一个函数

    const enhance= connect(mapStateToProps , mapDispatchToProps);

//enhance是一个高阶组件

    const ConnectedComponentA = enhance(ComponentA);

这种形式的高阶组件非常容易组合起来使用，因为当多个函数的输出和它的输入类型相同时，这些函数很容易组合到一起使用。例如，有f,g,h三个高阶组件作为参数，于是我们可以很方便地嵌套使用它们:`f(g(h(WrappedComponent）））`。这里有一个例外，即最内层的高阶组件h可以有多个参数，但其他高阶组件必须只能接收一个参数，只有这样才能保证内层的函数返回值和外层的函数参数数量一致(都只有1个)。

例如，将connect和另一个打印日志的高阶组件`withLog()`（注意，`withLog（）`的执行结果才是真正的高阶组件）联合使用：

//connect的参数是可选参数， 这里省略了mapDispatchToProps 参数

    const ConnectedComponentA = connect(mapStateToProps)(withLog()
    (ComponentA));

我们还可以定义一个工具函数`compose(...funcs):`

	function compose(...funcs) {
	  if (funcs.length === 0) {
	    return arg => arg;
	  }
	  if (funcs.length === 1) {
	    return funcs[0];
	  }
	  return funcs.reduce((a, b) => (...args) => a(b(args)));
	}

调用compose等价于`(...args)=>f(g(h(...args)))`。用compose函数可以把高阶组件嵌套的写法打平:

	const enhance=compose(
	  connect(mapStateToProps),
	  withLog();
	);
	
	const ConnectedComponentA = enhance (ComponentA);

像Redux 等很多第三方库都提供了compose的实现，compose结合高阶组件使用可以显著提高代码的可读性和逻辑的清晰度。