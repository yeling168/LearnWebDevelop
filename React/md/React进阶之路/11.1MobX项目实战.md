11.1 组织项目结构

使用MobX时，没有必要像使用Redux那样区分容器组件和展示组件。所有组件会自动根据state的变化进行渲染(当然，前提是组件使用observer/@observer包装)，所有组件都相当于展示组件。

MobX项目中，所有组件都需要使用observer/@observer包装吗？这也倒不是，如果组件中使用到可观测的state，组件就必须使用observer/@observer包装:否则可以不使用observer/@observer。但即使组件中没有使用可观测的state，使用observer/@observer包装组件也是有好处的，因为observer/@observer会将组件使用的不可观测的props转换成可观测的props，这样只有当props真正发生改变时，当前组件才会重新渲染。简单理解的话，observer/@observer的使用相当于重写了组件的shouldComponentUpdate方法。所以可以在项目中尽可能多地使用observer/@observer，这样可以提高所有组件的渲染效率。当然，这种方式也有一个缺点:难以在不使用MobX的项目中复用这些组件。


MobX中的state一般会封装在不同的store中。store不仅保存了state，还保存了操作state的方法。对于与领域直接相关的state，一般会创建专门的model实体类。用于描述state。

11.2设计store

Store的职责是将组件使用的业务逻辑和状态封装到单独的模块中，这样组件就可以专注于UI渲染。