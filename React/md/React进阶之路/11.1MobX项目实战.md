11.1 组织项目结构

使用MobX时，没有必要像使用Redux那样区分容器组件和展示组件。所有组件会自动根据state的变化进行渲染(当然，前提是组件使用observer/@observer包装)，所有组件都相当于展示组件。

MobX项目中，所有组件都需要使用observer/@observer包装吗？这也倒不是，如果组件中使用到可观测的state，组件就必须使用observer/@observer包装:否则可以不使用observer/@observer。但即使组件中没有使用可观测的state，使用observer/@observer包装组件也是有好处的，因为observer/@observer会将组件使用的不可观测的props转换成可观测的props，这样只有当props真正发生改变时，当前组件才会重新渲染。简单理解的话，observer/@observer的使用相当于重写了组件的shouldComponentUpdate方法。所以可以在项目中尽可能多地使用observer/@observer，这样可以提高所有组件的渲染效率。当然，这种方式也有一个缺点:难以在不使用MobX的项目中复用这些组件。


MobX中的state一般会封装在不同的store中。store不仅保存了state，还保存了操作state的方法。对于与领域直接相关的state，一般会创建专门的model实体类。用于描述state。

11.2设计store

Store的职责是将组件使用的业务逻辑和状态封装到单独的模块中，这样组件就可以专注于UI渲染。

state可以分为三类:与领域直接相关的领域状态数据，反映应用行为(登录状态，当前是否有API请求等)的应用状态数据和代表UI状态的UI状态数。后两种state一般不会涉及太多逻辑，仅仅是关于应用，UI的一些松散状态的读取和简单修改，封装这两种state的store实现也很直观。领域state的数据结构比较复杂，且往往涉及较多的逻辑处理。领域state可以使用普通对象来描述，也可以使用class来描述

	//使用普通对象
	
	var todo = {
	  id: 1,
	  title: "Todo1",
	  finished: false
	};
	
	//使用class
	
	class Todo {
	  id;
	  title;
	  finished;
	}

使用class比使用普通对象描述state有一些优势:

1)class内可以定义方法，可以自己保存上下文信息而不依赖外部，因此class描述的state比普通对象描述的state更容易被单独使用。

2)class内可以方便地混合使用可观测属性和非可观测属性，例如，在Todo class中，我们希望只有title和finished是可观测的，那么只需要在这两个属性前属性@observable，id继续作为不可观测属性使用

3)class描述的state辨识度高且容易进行类型校验。

所以，稍复杂的领域state 都建议大家使用class来描述。

一个领域store对应应用中的一个简单的领域概念，这个领域的state 和state的管理都由这个store负责。具体来讲，领域store的职责有：

1)实例化领域state，并且保证领域state知道它属于哪一个store

2)每一个领域store在应用中只能有一个实例对象，例如，应用中不能有两个todoListstore

3)更新领域state,无论是通过服务器端获取，还是来自纯客户端的修改

根据上面的介绍，我们可以为BBS创建5个store:AppStore,AuthStore,UIStore,PostsStore,CommentsStore。AppStore和AuthStore是应用状态store，UIStore是UI store，PostsStore和CommentsStore是领域store。另外，还可以创建PostModel和CommentModel两个class，代表领域state。

1.AppStore

AppStore管理的state包括应用当前的请求数量requestQuantity和应用的错误信息error:

