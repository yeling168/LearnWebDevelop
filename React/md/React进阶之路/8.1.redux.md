8.1.2 三大原则

Redux应用需要遵循三大原则，否则程序很容易出现难以察觉的问题。

1.唯一数据源

Redux应用只维护一个全局的状态对象，存储在Redux的store中。唯一数据源是一种集中式管理应用状态的方式，便于监控任意时刻应用的状态和调试应用，减少出错的可能性。

2.保持应用状态只读

在任何时候都不能直接修改应用状态。当需要修改应用状态时，必须发送一个action，由这个action描述如何修改应用状态。这一看似繁琐的修改状态的方式实际上是Redux状态管理流程的核心，保证了在大量复杂应用中状态管理的有序进行。

3.应用状态的改变通过纯函数完成

action表明修改应用状态的意图，真正对应用状态做修改的是reducer。reducer必须是纯函数，所以reducer在接收到action时，不能直接修改原来的状态对象，而是要创建一个新的状态对象返回。

纯函数是指满足以下两个条件的函数:

1)对于同样的参数值，函数的返回结果总是相同的，即该函数结果不依赖任何在程序执行过程中可能改变的变量。

2)函数的执行不会产生副作用。例如修改外部对象或输出到I/O设备。

8.2 主要组成

通过前面的介绍可以发现Redux应用的主要组成有action，redux和store。

8.2.1 action

action是Redux中信息的载体，是store唯一的信息来源。把action发送给store必须通过store的dispath方法。action是普通的JavaScript对象，但每个action必须有一个type属性描述action的类型，type一般被定义为字符串常量。除了type属性外，action的结构完全由自己决定，但应该确保action的结构能清晰地描述实际业务场景。一般通过action creator创建action，action creator是返回action函数。例如，下面是一个新增代办事项的action creator

	function addTodo(text){
	    return {
	        type:'ADD_TODO',
	        text
	    }
	}

8.2.2 reducer

action用于描述应用发生了什么操作，reducer则根据action做出响应，决定如何修改应用的状态state。既然是修改state，那么就应该在编写reducer前设计好state。state既可以包含服务器端获取的数据，也可以包含UI状态。

8.2.3 store

store 是Redux中的一个对象，也是action和reducer之间的桥梁。store主要负责以下几个工作:

1)保存应用状态

2)通过方法getState()访问应用状态

3)通过方法dispatch(action)发送更新状态的意图

4)通过方法subscribe(listener)注册监听函数，监听应用状态的改变

一个Redux应用中只有一个store，store保存了唯一数据源。store通过createStore()函数创建，创建时需要传递reducer作为参数，创建todos应用的store的代码如下

下面再来总结一下Redux的数据流过程

1)调用store.dispath(action)。一个action是用一个描述"发生了什么"的对象。store.dispatch(action)可以在应用的任何地方调用，包括组件，XHR的回调，甚至在定时器中。

2)Redux的store调用reducer函数。store传递两个参数给reducer：当前应用状态和action。reducer必须是一个纯函数，它的唯一职责是计算下一个应用的状态。

3)根reducer会把多个子reducer的返回结果组合成最终的应用状态。根reducer的构建形式完全取决于用户。Redux提供了combineReducers，方便把多个拆分的子reducer组合到一起，但完全可以不适用它。当使用combineReducers时，action会传递给每一个子reducer处理，子reducer处理后的结果会合并成最终的应用状态。

4)Redux的store保存根reducer返回的完整应用状态。此时，应用状态才完成更新。如果UI需要根据应用状态进行更新，那么这就是更新UI的时机。对于React应用而言，可以在这个时候调用组件的setState方法，根据新的应用状态更新UI。

8.3 在React 中使用Redux

8.3.2 展示组件和容器组件

根据组件意图的不同，可以将组件划分为两类：展示组件（presentational components ）和容器组件（ container components）。

展示组件负责应用的UI展示，也就是组件如何渲染，具有很强的内聚性。展示组件不关心渲染时使用的数据是如何获取到的，它只要知道了有了这些数据后，组件应该如何渲染就足够了。数据如何获取是容器组件负责的事情。

容器组件负责应用逻辑的处理，如发送网络请求，处理返回数据，将处理过的数据传递给展示组件使用等。容器组件还提供修改源数据的方法，通过展示组件的props传递给展示组件，当展示组件的状态变更引起源数据变化时，展示组件通过调用容器组件提供的方法同步这些变化。

展示组件和容器组件可以自由嵌套，一个容器组件可以包含多个展示组件和其他的容器组件，一个展示组件也可以包含容器组件和其他的展示组件。这样的分工可以使与UI渲染无直接关系的业务逻辑由容易组件集中负责，展示组件只关注UI的的渲染逻辑，从而使展示组件更容易被复用。对于非常简单的页面，一般只需要一个容易组件就够了，但对于复杂的页面，往往需要多个容器组件，否则所有的业务逻辑都在一个容器组件中处理的话，会导致这个组件非常复杂，同时这个组件获取到的源数据可能需要经过很多层组件props的传递才能到达最终使用的展示组件。

