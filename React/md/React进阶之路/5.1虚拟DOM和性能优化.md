5.1 虚拟DOM

虚拟DOM并非React 所独有的，它是一个独立的技术，只不过React 使用了这项技术来提高自身性能。

下面是一个DOM 结构：

	<div className="foo">
		<h1>hello React</h1>
	</div>

可以用这样的一个JavaScript对象来描述:

	{
	  type:'div',
	  props:{
	     className:'foo',
	     children:{
	       type:'h1',
	       props:{
	         children:'Hello React'
	      }
	    }
	  }
	}

有了虚拟DOM 这一层，当我们需要操作DOM 时，就可以操作虚拟DOM ， 而不操作真实DOM,虚拟DOM是普通的JavaScript对象，访JavaScript对象当然比访问真实DOM 要快得多。到这里，大家可以发现，虚拟DOM 并不是什么神奇的东西，它只是用来描述真实DOM 的JavaScript对象
而己。

5.2 Diff算法
React 采用声明式的API 描述Ul 结构，每次组件的状态或属性更新，组件的render 方法都会返回一个新的虚拟DOM 对象，用来表述新的U 结构。如果每次render 都直接使用新的虚拟DOM来生成真实DOM 结构，那么会带来大量对真实DOM 的操作，影响程序执行效率。事实上，React会通过比较两次虚拟DOM 结构的变化找出差异部分，更新到真实DOM 上，从而减少最终要在真实DOM 上执行的操作，提高程序执行效率。这一过程就是React 的调和过程（ Reconciliation) ,
其中的关键是比较两个树形结构的Diff算法。

<font color="#ff995" face="微软雅黑" size="3">在Diff算法中，比较的是两方是新的虚拟DOM和旧的虚拟DOM，而不是虚拟DOM和真是DOM，只不过Diff的结果会更新到真实DOM上。</font>

正常情况下，比较两个树形结构差异的算法的时间复杂度是O(N^3)，这个效率显然是无法接受的。React通过总结DOM的实际使用场景提出了两个在绝大多数实践场景下都成立的假设，基于这两个假设，React实现了在O(N)时间复杂度内完成两颗虚拟DOM树的比较。这两个假设是:

1)如果两个元素的类型不同，那么它们将生成两课不同的树
2)为列表中的元素设置key属性，用key标识对应的元素在多次render过程中是否发生变化

下面介绍在不同情况下， React 具体是如何比较两棵树的差异的。React 比较两棵树是从树的根节点开始比较的，根节点的类型不同， React 执行的操作也不同。

1. 当根节点是不同类型时

从div变成p、从Co mponentA 变成ComponentB ，或者从C omponentA变成div，这些都是节点类型发生变化的情况。根节点类型的变化是一个很大的变化， React会认为新的树和旧的树完全不同，不会再继续比较其他属性和子节点，而是把整棵树拆掉重建（包括虚拟DOM 树和真实DOM树）。这里需要注意，虚拟DOM 的节点类型分为两类： 一类是DOM 元素类型，比如div 、p 等；一类是React 组件类型，比如自定义的React 组件。在旧的虚拟DOM 树被拆除的过程中，旧的DOM
元素类型的节点会被销毁，旧的React 组件实例的componentWil!Unmount 会被调用；在重建的过程中，新的DOM 元素会被插入DOM 树中， 新的组件实例的componentW il!Mount 和
componentDidMount 方法会被调用。重建后的新的虚拟DOM 树又会被整体更新到真实DOM 树中。这种情况下，需要大量DOM 操作，更新效率最低。

  2.当根节点是相同的DOM元素类型时

如果两个根节点是相同类型的DOM 元素， React 会保留根节点，而比较根节点的属性，然后只更新那些变化了的属性。例如：

	<div className="foo" title="React"></div>
	<div className="bar" title="React"></div>

React比较这两个元素，发现只有className属性发生了变化，然后只更新虚拟DOM树和真实DOM树中对应节点的这一属性。

3.当根节点是相同的组件类型时

如果两个根节点是相同类型的组件，对应的组件实例不会被销毁，只是会执行更新操作，同步变化的属性到虚拟DOM 树上，这一过程组件实例的componentWil!ReceiveProps()和componentWillUpdate()会被调用。注意，对于组件类型的节点， React是无法直接知道如何更新真实DOM树的，需要在组件更新井且render方法执行完成后，根据render 返回的虚拟DOM结构决定如何更新真实DOM 树。

比较完根节点后，React会以同样的原则继续递归比较子节点，每一个子节点相对于其层级以下的节点来说又是一个根节点。如此递归比较，直到比较完两棵树上的所有节点，计算得到最终的差异，更新到DOM树中。

当一个节点有多个子节点时，默认情况下， React 只会按照顺序逐一比较两棵树上对应的子节点。例如，比较下面的两个节点，两棵树上的`＜li>first</li＞`和`<li>second</li＞`子节点会分别被匹配，
最终只会插入一个新的节点`＜li>third</li＞`。

	<ul>
	   <li>first</li>
	   <li>second</li>
	</ul>

    <ul>
	   <li>first</li>
	   <li>second</li>
       <li>third</li>
	</ul>